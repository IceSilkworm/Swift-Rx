//
//  Construction_03.swift
//  练习
//
//  Created by hudun on 2017/8/21.
//  Copyright © 2017年 hudun. All rights reserved.
//

import UIKit

class Construction_03: NSObject {

    //MARK: - “类的继承和构造过程”
    
    /*
     
     “Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们分别是指定构造器和便利构造器。”
     
     MARK: - “指定构造器和便利构造器”
     
     指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。”
     
     “每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。具体内容请参考后续章节构造器的自动继承。
     
     便利构造器是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。
     
     你应当只在必要的时候为类提供便利构造器，比方说某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造过程更清晰明了。”
     
     
     “类的指定构造器的写法跟值类型简单构造器一样：
     
     init(parameters) {
          statements
     }
     便利构造器也采用相同样式的写法，但需要在init关键字之前放置convenience关键字，并使用空格将它们俩分开：
     
     convenience init(parameters) {
          statements
     }”
     

     
     MARK: - “类的构造器代理规则
     
     为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用：”
     
     “为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用：”
     
     规则 1
     指定构造器必须调用其直接父类的的指定构造器。
     
     规则 2
     便利构造器必须调用同类中定义的其它构造器。
     
     规则 3
     便利构造器必须最终导致一个指定构造器被调用。
     
     一个更方便记忆的方法是：
     
     指定构造器必须总是向上代理
     便利构造器必须总是横向代理”
     
     
     
     
     */
    
    
    /*
     
     “两段式构造过程
     
     Swift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。”
     
     “Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程能不出错地完成：
     
     安全检查 1
     指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。”
     
     
     “如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类引入的属性在它往上代理之前先完成初始化。
     
     安全检查 2
     指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。
     
     安全检查 3
     便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。
     
     安全检查 4
     构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。
     
     
     
     类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例才会成为有效实例，才能访问属性和调用方法。
     
     以下是两段式构造过程中基于上述安全检查的构造流程展示：”
     

     阶段 1
     某个指定构造器或便利构造器被调用。
     完成新实例内存的分配，但此时内存还没有被初始化。
     指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。
     指定构造器将调用父类的构造器，完成父类属性的初始化。
     这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。”
     “当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。
     
     
     
     阶段 2
     从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等。
     最终，任意构造器链中的便利构造器可以有机会定制实例和使用self。”
     
     

     */
    
    
    
    
    /*
     
     //MARK: -“构造器的自动继承”
     
     “假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则适用：
     
     规则 1
     如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。
     
     规则 2
     如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器。
     
     即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。
     
     注意
     对于规则 2，子类可以将父类的指定构造器实现为便利构造器。”
     
     
     
     */
    func run() {
        
        
        let _ = Food(name: "Bacon")
        // namedMeat 的名字是 "Bacon”
        
        //“Food类中的构造器init(name: String)被定义为一个指定构造器，因为它能确保Food实例的所有存储型属性都被初始化。Food类没有父类，所以init(name: String)构造器不需要调用super.init()来完成构造过程。
        
        //Food类同样提供了一个没有参数的便利构造器init()。这个init()构造器为新食物提供了一个默认的占位名字，通过横向代理到指定构造器init(name: String)并给参数name传值[Unnamed]来实现：
        
        _ = Food()
        // mysteryMeat 的名字是 [Unnamed]”
        
        
        let _ = RecipeIngredient()
        let _ = RecipeIngredient(name: "Bacon")
        let _ = RecipeIngredient(name: "Eggs", quantity: 6)
        
        
    }
}


class Food {
    var name: String
    init(name: String) {
        self.name = name
    }
    convenience init() {
        self.init(name: "[Unnamed]")
    }
}


class RecipeIngredient: Food {
    var quantity: Int
    init(name: String, quantity: Int) {
        self.quantity = quantity
        super.init(name: name)
    }
    override convenience init(name: String) {
        self.init(name: name, quantity: 1)
    }
}

//“这个便利构造器只是简单地横向代理到类中的指定构造器，并为quantity参数传递1。

//注意，RecipeIngredient的便利构造器init(name: String)使用了跟Food中指定构造器init(name: String)相同的参数。由于这个便利构造器重写了父类的指定构造器init(name: String)，因此必须在前面使用override修饰符（参见构造器的继承和重写）。

//尽管RecipeIngredient将父类的指定构造器重写为了便利构造器，它依然提供了父类的所有指定构造器的实现。因此，RecipeIngredient会自动继承父类的所有便利构造器。”

class ShoppingListItem: RecipeIngredient {
    var purchased = false
    
     var description: String {
        var output = "\(quantity) x \(name)"
        output += purchased ? " ✔" : " ✘"
        return output
    }
}
//注意
//ShoppingListItem没有定义构造器来为purchased提供初始值，因为添加到购物单的物品的初始状态总是未购买。”


